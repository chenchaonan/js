<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>

</body>
</html>
<script>
    /*
    *构造函数模式：创建一个自定义类，并且创建这个类的实例
    * 类是一个函数
    *实例是一个对象数据类型
    * this.xxx=值，给当前实例添加私有属性
    *
    *每一个函数数据类型（普通函数，类（内置类，自定义类）），都有一个自带的属性prototype（原型）对象数据类型的值，存储当前类所属实例的公用的属性和方法，
    * prototype属性解决实例间属性共享。
    * 每一个对象数据类型，（普通对象，实例，函数，原型）
    * instanceof检测当前的实例是否属于某一个类，返回true或者false
    *
    *
    *
    * */

    function Tab() {//类中的this指向当前实例
        this.id=1;
        this.name='zhufneg';
    }
    var tab1=new Tab(1,'hello');//构造函数模式执行，作为一个类，并且返回这个类的实例。
    var tab2=new Tab(2,'world');


    //hasOwnProperty检测一个属性是都是这个对象的私有属性。
    //in 检测一个属性是否属于这个对象。不管是共有还是私有，它都是一个属性。
    console.log(tab1.hasOwnProperty('id'));
    console.log('id' in tab1);

//    function hasPublicProperty(obj, attr) {
//        if(attr in obj){
//            return !obj hasPublicProperty(attr)
//        }
//    }



    console.log(tab1 === tab2);//false 每一个实例都是一个单独的个体


    console.log(Tab.prototype.constructor === Tab);//true
    Tab.prototype.say=function () {
        console.log(this.name);//this是谁就看函数执行的时候，点前面是谁。
    };
    tab1.say();


    /*
    * 所有对象数据类型，都有一个天生自带的属性__proto__，指向所属类的原型。
    *
    * 查找机制(原型链查找)：对象名.属性名 先看自己私有属性中是否存在，如果存在找到的是私有的，
    * 如果不存在，就根据__proto__找到所属类原型上的公用属性和方法。如果原型上没有，就根据原型的__proto__继续查找，
    * 一直找到(基类原型)Object.prototype，如果也没有，返回undefinedned
    *
    * */
    console.log(tab1.say === Tab.prototype.say);



    //可枚举，列举出来，通过for in遍历出来，

    //基本数据类型需要实例话之后才能查看原型链。

</script>